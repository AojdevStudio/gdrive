---
phase: 03-dry-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/calendar/utils.ts
  - src/modules/calendar/__tests__/utils.test.ts
autonomous: true

must_haves:
  truths:
    - "parseAttendees function exists only in calendar/utils.ts"
    - "buildEventResult function exists only in calendar/utils.ts"
    - "All utility tests pass independently"
  artifacts:
    - path: "src/modules/calendar/utils.ts"
      provides: "parseAttendees and buildEventResult utility functions"
      exports: ["parseAttendees", "buildEventResult", "validateEventTimes"]
    - path: "src/modules/calendar/__tests__/utils.test.ts"
      provides: "Unit tests for calendar utilities"
      min_lines: 100
  key_links:
    - from: "src/modules/calendar/utils.ts"
      to: "./types.js"
      via: "Type imports for Attendee and EventResult"
      pattern: "import.*Attendee.*EventResult.*from.*types"
---

<objective>
Create shared calendar utility functions for parseAttendees and buildEventResult in calendar/utils.ts.

Purpose: Extract the first copy of duplicated code into shared utilities with comprehensive tests. This establishes the canonical implementation that will be imported by consumer files in Plan 02.

Output:
- Extended `src/modules/calendar/utils.ts` with parseAttendees and buildEventResult functions
- New `src/modules/calendar/__tests__/utils.test.ts` with comprehensive unit tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dry-extraction/03-RESEARCH.md

Key source files (contains canonical implementations to extract):
@src/modules/calendar/create.ts (parseAttendees lines 20-61, buildEventResult pattern lines 244-357)
@src/modules/calendar/utils.ts (existing validateEventTimes to extend)
@src/modules/calendar/types.ts (Attendee and EventResult types)
@src/modules/gmail/__tests__/utils.test.ts (test pattern to follow)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parseAttendees to calendar/utils.ts</name>
  <files>src/modules/calendar/utils.ts</files>
  <action>
Add the parseAttendees function to src/modules/calendar/utils.ts after the existing validateEventTimes function.

Import required types at the top:
```typescript
import type { calendar_v3 } from 'googleapis';
import type { Attendee } from './types.js';
```

Add the function (exact implementation from create.ts lines 20-61):
```typescript
/**
 * Parse attendees from Google Calendar API response
 * Transforms Google API schema into type-safe Attendee objects
 *
 * @param attendees Google Calendar API attendees array
 * @returns Parsed attendees array, or undefined if empty/missing
 */
export function parseAttendees(
  attendees: calendar_v3.Schema$EventAttendee[] | undefined
): Attendee[] | undefined {
  if (!attendees || attendees.length === 0) {
    return undefined;
  }

  return attendees.map((attendee) => {
    const parsed: Attendee = {
      email: attendee.email ?? '',
    };

    // Use intermediate variables to help TypeScript narrow types
    const displayName = attendee.displayName;
    if (typeof displayName === 'string') {
      parsed.displayName = displayName;
    }

    const responseStatus = attendee.responseStatus;
    if (responseStatus === 'needsAction' || responseStatus === 'declined' || responseStatus === 'tentative' || responseStatus === 'accepted') {
      parsed.responseStatus = responseStatus;
    }

    if (attendee.organizer === true) {
      parsed.organizer = true;
    } else if (attendee.organizer === false) {
      parsed.organizer = false;
    }

    if (attendee.self === true) {
      parsed.self = true;
    } else if (attendee.self === false) {
      parsed.self = false;
    }

    if (attendee.optional === true) {
      parsed.optional = true;
    } else if (attendee.optional === false) {
      parsed.optional = false;
    }

    return parsed;
  });
}
```

CRITICAL: The boolean checks (attendee.organizer === true/false) are required for exactOptionalPropertyTypes compliance. Do NOT simplify to if (attendee.organizer).
  </action>
  <verify>
Run: `npm run build` - should compile without errors
Run: `grep -n "export function parseAttendees" src/modules/calendar/utils.ts` - should show the function
  </verify>
  <done>parseAttendees function exported from calendar/utils.ts with correct type signature</done>
</task>

<task type="auto">
  <name>Task 2: Add buildEventResult to calendar/utils.ts</name>
  <files>src/modules/calendar/utils.ts</files>
  <action>
Add the buildEventResult function to src/modules/calendar/utils.ts after parseAttendees.

Add EventResult to the type imports:
```typescript
import type { Attendee, EventResult } from './types.js';
```

Add the function (based on create.ts lines 244-357, using parseAttendees internally):
```typescript
/**
 * Build EventResult from Google Calendar API response
 * Transforms Google API event schema into type-safe EventResult
 *
 * @param responseData Google Calendar API event object
 * @returns Type-safe EventResult object
 */
export function buildEventResult(
  responseData: calendar_v3.Schema$Event
): EventResult {
  const result: EventResult = {
    eventId: responseData.id!,
  };

  // Only add properties if they exist (exactOptionalPropertyTypes compliance)
  if (responseData.status) {
    result.status = responseData.status;
  }
  if (responseData.htmlLink) {
    result.htmlLink = responseData.htmlLink;
  }
  if (responseData.created) {
    result.created = responseData.created;
  }
  if (responseData.updated) {
    result.updated = responseData.updated;
  }
  if (responseData.summary) {
    result.summary = responseData.summary;
  }
  if (responseData.description) {
    result.description = responseData.description;
  }
  if (responseData.location) {
    result.location = responseData.location;
  }

  // Creator
  if (responseData.creator) {
    result.creator = {};
    if (responseData.creator.email) {
      result.creator.email = responseData.creator.email;
    }
    if (responseData.creator.displayName) {
      result.creator.displayName = responseData.creator.displayName;
    }
  }

  // Organizer
  if (responseData.organizer) {
    result.organizer = {};
    if (responseData.organizer.email) {
      result.organizer.email = responseData.organizer.email;
    }
    if (responseData.organizer.displayName) {
      result.organizer.displayName = responseData.organizer.displayName;
    }
  }

  // Start/End times
  if (responseData.start) {
    result.start = {};
    if (responseData.start.dateTime) {
      result.start.dateTime = responseData.start.dateTime;
    }
    if (responseData.start.date) {
      result.start.date = responseData.start.date;
    }
    if (responseData.start.timeZone) {
      result.start.timeZone = responseData.start.timeZone;
    }
  }

  if (responseData.end) {
    result.end = {};
    if (responseData.end.dateTime) {
      result.end.dateTime = responseData.end.dateTime;
    }
    if (responseData.end.date) {
      result.end.date = responseData.end.date;
    }
    if (responseData.end.timeZone) {
      result.end.timeZone = responseData.end.timeZone;
    }
  }

  // Recurrence
  if (responseData.recurrence && responseData.recurrence.length > 0) {
    result.recurrence = responseData.recurrence;
  }

  // Attendees (uses parseAttendees utility)
  const parsedAttendees = parseAttendees(responseData.attendees);
  if (parsedAttendees) {
    result.attendees = parsedAttendees;
  }

  // Conference data
  if (responseData.conferenceData) {
    result.conferenceData = responseData.conferenceData;
  }

  // Attachments
  if (responseData.attachments && responseData.attachments.length > 0) {
    result.attachments = responseData.attachments.map((att) => ({
      fileId: att.fileId || '',
      fileUrl: att.fileUrl || '',
      title: att.title || '',
    }));
  }

  // Reminders
  if (responseData.reminders) {
    result.reminders = {
      useDefault: responseData.reminders.useDefault || false,
    };
    if (responseData.reminders.overrides && responseData.reminders.overrides.length > 0) {
      result.reminders.overrides = responseData.reminders.overrides.map((override) => ({
        method: override.method || 'popup',
        minutes: override.minutes || 0,
      }));
    }
  }

  return result;
}
```

CRITICAL:
- Uses conditional assignment (if checks) NOT || undefined for optional properties
- Calls parseAttendees internally for attendees parsing
- Uses type cast `att` without explicit typing (follows create.ts pattern)
  </action>
  <verify>
Run: `npm run build` - should compile without errors
Run: `grep -n "export function buildEventResult" src/modules/calendar/utils.ts` - should show the function
  </verify>
  <done>buildEventResult function exported from calendar/utils.ts calling parseAttendees internally</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive unit tests for calendar utilities</name>
  <files>src/modules/calendar/__tests__/utils.test.ts</files>
  <action>
Create src/modules/calendar/__tests__/utils.test.ts with comprehensive tests for parseAttendees and buildEventResult.

Follow the pattern from src/modules/gmail/__tests__/utils.test.ts.

```typescript
/**
 * Tests for calendar utility functions
 */
import { describe, expect, test } from '@jest/globals';
import { parseAttendees, buildEventResult, validateEventTimes } from '../utils.js';

describe('Calendar Utils', () => {
  describe('validateEventTimes', () => {
    test('accepts valid dateTime event', () => {
      expect(() => validateEventTimes(
        { dateTime: '2026-01-10T14:00:00-06:00' },
        { dateTime: '2026-01-10T15:00:00-06:00' }
      )).not.toThrow();
    });

    test('accepts valid all-day event', () => {
      expect(() => validateEventTimes(
        { date: '2026-01-10' },
        { date: '2026-01-11' }
      )).not.toThrow();
    });

    test('throws if end is before start for dateTime', () => {
      expect(() => validateEventTimes(
        { dateTime: '2026-01-10T15:00:00-06:00' },
        { dateTime: '2026-01-10T14:00:00-06:00' }
      )).toThrow('Event end time must be after start time');
    });

    test('throws if end is before start for date', () => {
      expect(() => validateEventTimes(
        { date: '2026-01-11' },
        { date: '2026-01-10' }
      )).toThrow('Event end time must be after start time');
    });

    test('throws if mixing date and dateTime in start', () => {
      expect(() => validateEventTimes(
        { date: '2026-01-10', dateTime: '2026-01-10T14:00:00-06:00' },
        { dateTime: '2026-01-10T15:00:00-06:00' }
      )).toThrow("All-day events should use 'date' field, not 'dateTime'");
    });
  });

  describe('parseAttendees', () => {
    test('returns undefined for undefined input', () => {
      const result = parseAttendees(undefined);
      expect(result).toBeUndefined();
    });

    test('returns undefined for empty array', () => {
      const result = parseAttendees([]);
      expect(result).toBeUndefined();
    });

    test('parses basic attendee with email only', () => {
      const result = parseAttendees([{ email: 'user@example.com' }]);
      expect(result).toHaveLength(1);
      expect(result![0].email).toBe('user@example.com');
      expect(result![0].displayName).toBeUndefined();
      expect(result![0].responseStatus).toBeUndefined();
    });

    test('parses attendee with null email as empty string', () => {
      const result = parseAttendees([{ email: null as unknown as string }]);
      expect(result![0].email).toBe('');
    });

    test('parses attendee with displayName', () => {
      const result = parseAttendees([{
        email: 'user@example.com',
        displayName: 'Test User'
      }]);
      expect(result![0].displayName).toBe('Test User');
    });

    test('parses valid responseStatus values', () => {
      const statuses = ['needsAction', 'declined', 'tentative', 'accepted'] as const;
      for (const status of statuses) {
        const result = parseAttendees([{ email: 'test@example.com', responseStatus: status }]);
        expect(result![0].responseStatus).toBe(status);
      }
    });

    test('filters invalid responseStatus values', () => {
      const result = parseAttendees([{
        email: 'user@example.com',
        responseStatus: 'invalid-status' as 'accepted'
      }]);
      expect(result![0].responseStatus).toBeUndefined();
    });

    test('parses organizer true', () => {
      const result = parseAttendees([{ email: 'org@example.com', organizer: true }]);
      expect(result![0].organizer).toBe(true);
    });

    test('parses organizer false', () => {
      const result = parseAttendees([{ email: 'user@example.com', organizer: false }]);
      expect(result![0].organizer).toBe(false);
    });

    test('does not set organizer when undefined', () => {
      const result = parseAttendees([{ email: 'user@example.com' }]);
      expect(result![0].organizer).toBeUndefined();
    });

    test('parses self and optional booleans', () => {
      const result = parseAttendees([{
        email: 'user@example.com',
        self: true,
        optional: false
      }]);
      expect(result![0].self).toBe(true);
      expect(result![0].optional).toBe(false);
    });

    test('parses attendee with all properties', () => {
      const result = parseAttendees([{
        email: 'user@example.com',
        displayName: 'Test User',
        responseStatus: 'accepted',
        organizer: true,
        self: false,
        optional: false
      }]);
      expect(result![0]).toEqual({
        email: 'user@example.com',
        displayName: 'Test User',
        responseStatus: 'accepted',
        organizer: true,
        self: false,
        optional: false
      });
    });

    test('parses multiple attendees', () => {
      const result = parseAttendees([
        { email: 'user1@example.com' },
        { email: 'user2@example.com' }
      ]);
      expect(result).toHaveLength(2);
      expect(result![0].email).toBe('user1@example.com');
      expect(result![1].email).toBe('user2@example.com');
    });
  });

  describe('buildEventResult', () => {
    test('builds minimal result with only eventId', () => {
      const result = buildEventResult({ id: 'event123' });
      expect(result.eventId).toBe('event123');
      expect(result.summary).toBeUndefined();
      expect(result.description).toBeUndefined();
    });

    test('builds result with basic properties', () => {
      const result = buildEventResult({
        id: 'event123',
        status: 'confirmed',
        htmlLink: 'https://calendar.google.com/event/123',
        summary: 'Test Event',
        description: 'Test Description',
        location: 'Test Location'
      });
      expect(result.eventId).toBe('event123');
      expect(result.status).toBe('confirmed');
      expect(result.htmlLink).toBe('https://calendar.google.com/event/123');
      expect(result.summary).toBe('Test Event');
      expect(result.description).toBe('Test Description');
      expect(result.location).toBe('Test Location');
    });

    test('builds result with created and updated timestamps', () => {
      const result = buildEventResult({
        id: 'event123',
        created: '2026-01-01T00:00:00Z',
        updated: '2026-01-02T00:00:00Z'
      });
      expect(result.created).toBe('2026-01-01T00:00:00Z');
      expect(result.updated).toBe('2026-01-02T00:00:00Z');
    });

    test('builds result with creator', () => {
      const result = buildEventResult({
        id: 'event123',
        creator: { email: 'creator@example.com', displayName: 'Creator' }
      });
      expect(result.creator).toEqual({
        email: 'creator@example.com',
        displayName: 'Creator'
      });
    });

    test('builds result with partial creator (email only)', () => {
      const result = buildEventResult({
        id: 'event123',
        creator: { email: 'creator@example.com' }
      });
      expect(result.creator?.email).toBe('creator@example.com');
      expect(result.creator?.displayName).toBeUndefined();
    });

    test('builds result with organizer', () => {
      const result = buildEventResult({
        id: 'event123',
        organizer: { email: 'org@example.com', displayName: 'Organizer' }
      });
      expect(result.organizer).toEqual({
        email: 'org@example.com',
        displayName: 'Organizer'
      });
    });

    test('builds result with start/end dateTime', () => {
      const result = buildEventResult({
        id: 'event123',
        start: { dateTime: '2026-01-10T14:00:00-06:00', timeZone: 'America/Chicago' },
        end: { dateTime: '2026-01-10T15:00:00-06:00', timeZone: 'America/Chicago' }
      });
      expect(result.start).toEqual({
        dateTime: '2026-01-10T14:00:00-06:00',
        timeZone: 'America/Chicago'
      });
      expect(result.end).toEqual({
        dateTime: '2026-01-10T15:00:00-06:00',
        timeZone: 'America/Chicago'
      });
    });

    test('builds result with start/end date (all-day)', () => {
      const result = buildEventResult({
        id: 'event123',
        start: { date: '2026-01-10' },
        end: { date: '2026-01-11' }
      });
      expect(result.start).toEqual({ date: '2026-01-10' });
      expect(result.end).toEqual({ date: '2026-01-11' });
    });

    test('builds result with recurrence', () => {
      const result = buildEventResult({
        id: 'event123',
        recurrence: ['RRULE:FREQ=WEEKLY;COUNT=10']
      });
      expect(result.recurrence).toEqual(['RRULE:FREQ=WEEKLY;COUNT=10']);
    });

    test('does not include empty recurrence array', () => {
      const result = buildEventResult({
        id: 'event123',
        recurrence: []
      });
      expect(result.recurrence).toBeUndefined();
    });

    test('builds result with attendees using parseAttendees', () => {
      const result = buildEventResult({
        id: 'event123',
        attendees: [
          { email: 'user@example.com', displayName: 'User', responseStatus: 'accepted' }
        ]
      });
      expect(result.attendees).toHaveLength(1);
      expect(result.attendees![0].email).toBe('user@example.com');
      expect(result.attendees![0].displayName).toBe('User');
      expect(result.attendees![0].responseStatus).toBe('accepted');
    });

    test('builds result with conferenceData', () => {
      const conferenceData = {
        entryPoints: [{ entryPointType: 'video', uri: 'https://meet.google.com/abc-defg-hij' }]
      };
      const result = buildEventResult({
        id: 'event123',
        conferenceData
      });
      expect(result.conferenceData).toEqual(conferenceData);
    });

    test('builds result with attachments', () => {
      const result = buildEventResult({
        id: 'event123',
        attachments: [
          { fileId: 'file1', fileUrl: 'https://drive.google.com/file1', title: 'Doc 1' }
        ]
      });
      expect(result.attachments).toEqual([
        { fileId: 'file1', fileUrl: 'https://drive.google.com/file1', title: 'Doc 1' }
      ]);
    });

    test('handles attachments with missing fields', () => {
      const result = buildEventResult({
        id: 'event123',
        attachments: [{}]
      });
      expect(result.attachments).toEqual([{ fileId: '', fileUrl: '', title: '' }]);
    });

    test('does not include empty attachments array', () => {
      const result = buildEventResult({
        id: 'event123',
        attachments: []
      });
      expect(result.attachments).toBeUndefined();
    });

    test('builds result with reminders using default', () => {
      const result = buildEventResult({
        id: 'event123',
        reminders: { useDefault: true }
      });
      expect(result.reminders).toEqual({ useDefault: true });
    });

    test('builds result with reminders with overrides', () => {
      const result = buildEventResult({
        id: 'event123',
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'email', minutes: 30 },
            { method: 'popup', minutes: 10 }
          ]
        }
      });
      expect(result.reminders).toEqual({
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 30 },
          { method: 'popup', minutes: 10 }
        ]
      });
    });

    test('handles reminders overrides with missing fields', () => {
      const result = buildEventResult({
        id: 'event123',
        reminders: {
          useDefault: false,
          overrides: [{}]
        }
      });
      expect(result.reminders?.overrides).toEqual([{ method: 'popup', minutes: 0 }]);
    });

    test('builds complete result with all properties', () => {
      const result = buildEventResult({
        id: 'event123',
        status: 'confirmed',
        htmlLink: 'https://calendar.google.com/event/123',
        created: '2026-01-01T00:00:00Z',
        updated: '2026-01-02T00:00:00Z',
        summary: 'Test Event',
        description: 'Test Description',
        location: 'Test Location',
        creator: { email: 'creator@example.com' },
        organizer: { email: 'org@example.com' },
        start: { dateTime: '2026-01-10T14:00:00-06:00' },
        end: { dateTime: '2026-01-10T15:00:00-06:00' },
        recurrence: ['RRULE:FREQ=WEEKLY'],
        attendees: [{ email: 'user@example.com' }],
        reminders: { useDefault: true }
      });

      expect(result.eventId).toBe('event123');
      expect(result.status).toBe('confirmed');
      expect(result.summary).toBe('Test Event');
      expect(result.start?.dateTime).toBe('2026-01-10T14:00:00-06:00');
      expect(result.attendees).toHaveLength(1);
    });
  });
});
```
  </action>
  <verify>
Run: `npm test -- --testPathPattern="calendar/.*utils" --passWithNoTests` - all tests should pass
Run: `wc -l src/modules/calendar/__tests__/utils.test.ts` - should be > 100 lines
  </verify>
  <done>Comprehensive test suite for parseAttendees and buildEventResult with 30+ test cases</done>
</task>

</tasks>

<verification>
1. Run full build: `npm run build` - must pass
2. Run calendar utils tests: `npm test -- --testPathPattern="calendar/.*utils"` - all tests pass
3. Verify exports: `grep -E "^export function" src/modules/calendar/utils.ts` - shows all 3 functions
4. Verify no duplicate function definitions in utils.ts
</verification>

<success_criteria>
- calendar/utils.ts exports parseAttendees, buildEventResult, and validateEventTimes
- utils.test.ts has comprehensive coverage for all utility functions
- All tests pass
- Code compiles without TypeScript errors
- exactOptionalPropertyTypes compliance maintained (no || undefined patterns)
</success_criteria>

<output>
After completion, create `.planning/phases/03-dry-extraction/03-01-SUMMARY.md`
</output>
