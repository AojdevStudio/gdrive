---
phase: 02-security-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/gmail/utils.ts
  - src/modules/gmail/compose.ts
  - src/modules/gmail/send.ts
  - src/modules/gmail/__tests__/utils.test.ts
  - src/modules/gmail/__tests__/compose.test.ts
autonomous: true

must_haves:
  truths:
    - "Gmail compose.ts validates email addresses before creating drafts"
    - "Gmail compose.ts sanitizes headers to prevent CRLF injection"
    - "Gmail compose.ts encodes non-ASCII subjects with RFC 2047"
    - "Both compose.ts and send.ts use the same validation functions"
  artifacts:
    - path: "src/modules/gmail/utils.ts"
      provides: "Shared validation utilities for Gmail operations"
      exports: ["sanitizeHeaderValue", "isValidEmailAddress", "encodeSubject", "validateAndSanitizeRecipients", "encodeToBase64Url"]
    - path: "src/modules/gmail/compose.ts"
      provides: "Draft creation with security validation"
      contains: "validateAndSanitizeRecipients"
    - path: "src/modules/gmail/send.ts"
      provides: "Message sending importing from utils"
      contains: "import { sanitizeHeaderValue"
    - path: "src/modules/gmail/__tests__/utils.test.ts"
      provides: "Unit tests for validation utilities"
      min_lines: 100
    - path: "src/modules/gmail/__tests__/compose.test.ts"
      provides: "Security tests for compose validation"
      min_lines: 60
  key_links:
    - from: "src/modules/gmail/compose.ts"
      to: "src/modules/gmail/utils.ts"
      via: "imports validation functions"
      pattern: "import.*validateAndSanitizeRecipients.*from.*utils"
    - from: "src/modules/gmail/send.ts"
      to: "src/modules/gmail/utils.ts"
      via: "imports validation functions"
      pattern: "import.*sanitizeHeaderValue.*from.*utils"
---

<objective>
Extract email validation from send.ts to shared utils.ts and use it in compose.ts (SEC-02).

Purpose: The draft creation function in compose.ts lacks the comprehensive validation, sanitization, and encoding present in send.ts. This creates an inconsistency where malformed drafts can be created but fail when sent. Both operations should use the same security validation.

Output: New gmail/utils.ts with extracted functions, updated compose.ts with validation, updated send.ts to import from utils, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-security-fixes/02-RESEARCH.md

# Source files to modify
@src/modules/gmail/send.ts
@src/modules/gmail/compose.ts

# Test pattern reference
@src/modules/gmail/__tests__/labels.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gmail/utils.ts with extracted validation functions</name>
  <files>
    src/modules/gmail/utils.ts
  </files>
  <action>
Create new file `src/modules/gmail/utils.ts` with the validation functions extracted from send.ts:

```typescript
/**
 * Gmail shared utilities - security validation and encoding functions
 * Used by both compose.ts and send.ts for consistent security
 */

/**
 * Sanitize header field value by stripping CR/LF to prevent header injection
 * @param value Header field value to sanitize
 * @returns Sanitized value with CR/LF removed
 */
export function sanitizeHeaderValue(value: string): string {
  // Remove any CR (\r) or LF (\n) characters to prevent header injection attacks
  return value.replace(/[\r\n]/g, '');
}

/**
 * Simple RFC 5322-like email address validation
 * Validates basic structure: local-part@domain
 * Supports "Name <email>" format
 * @param email Email address to validate
 * @returns true if email is valid
 */
export function isValidEmailAddress(email: string): boolean {
  // Extract email from "Name <email>" format if present
  const match = email.match(/<([^>]+)>/) || [null, email];
  const address = match[1]?.trim() || email.trim();

  // Basic RFC 5322 pattern: local-part@domain
  // Local part: alphanumeric, dots, underscores, hyphens, plus signs
  // Domain: alphanumeric segments separated by dots
  const emailPattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailPattern.test(address);
}

/**
 * Encode subject using RFC 2047 MIME encoded-word for non-ASCII characters
 * Uses UTF-8 base64 encoding: =?UTF-8?B?<base64>?=
 * @param subject Subject line to encode
 * @returns Encoded subject (unchanged if ASCII-only)
 */
export function encodeSubject(subject: string): string {
  // Check if subject contains non-ASCII characters (char codes > 127)
  const hasNonAscii = [...subject].some(char => char.charCodeAt(0) > 127);

  if (!hasNonAscii) {
    // ASCII only - just sanitize and return
    return sanitizeHeaderValue(subject);
  }

  // Encode as RFC 2047 MIME encoded-word using UTF-8 base64
  const encoded = Buffer.from(subject, 'utf-8').toString('base64');
  return `=?UTF-8?B?${encoded}?=`;
}

/**
 * Validate and sanitize email addresses
 * @param emails Array of email addresses to validate
 * @param fieldName Name of the field (for error messages)
 * @returns Sanitized addresses
 * @throws Error if any email is invalid
 */
export function validateAndSanitizeRecipients(emails: string[], fieldName: string): string[] {
  return emails.map(email => {
    const sanitized = sanitizeHeaderValue(email);
    if (!isValidEmailAddress(sanitized)) {
      throw new Error(`Invalid email address in ${fieldName}: ${sanitized}`);
    }
    return sanitized;
  });
}

/**
 * Encode message to base64url format for Gmail API
 * @param content String content to encode
 * @returns Base64url encoded string
 */
export function encodeToBase64Url(content: string): string {
  return Buffer.from(content)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
```
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles without errors.
  </verify>
  <done>
- File exists at `src/modules/gmail/utils.ts`
- All 5 functions are exported with JSDoc comments
- Each function has proper TypeScript types
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Update send.ts to import from utils.ts</name>
  <files>
    src/modules/gmail/send.ts
  </files>
  <action>
Update send.ts to use the shared utilities instead of local functions:

1. Add import at the top of the file (after existing imports, around line 13):
```typescript
import {
  sanitizeHeaderValue,
  isValidEmailAddress,
  encodeSubject,
  validateAndSanitizeRecipients,
  encodeToBase64Url,
} from './utils.js';
```

2. Remove the local function definitions (lines ~17-68):
   - Remove `isValidEmailAddress` function (lines ~17-28)
   - Remove `sanitizeHeaderValue` function (lines ~30-36)
   - Remove `encodeSubject` function (lines ~38-54)
   - Remove `validateAndSanitizeRecipients` function (lines ~56-68)

3. Update the base64url encoding in `sendMessage` function (around line 162-166):
   - Replace the inline encoding:
   ```typescript
   // OLD:
   const encodedMessage = Buffer.from(emailMessage)
     .toString('base64')
     .replace(/\+/g, '-')
     .replace(/\//g, '_')
     .replace(/=+$/, '');

   // NEW:
   const encodedMessage = encodeToBase64Url(emailMessage);
   ```

The `buildEmailMessage` function stays in send.ts as it's specific to sending (Bcc handling differs from drafts).
  </action>
  <verify>
Run `npm run build` to verify imports resolve and TypeScript compiles.
Run `npm test -- --testPathPattern="gmail"` to verify existing Gmail tests still pass.
  </verify>
  <done>
- send.ts imports from ./utils.js
- Local function definitions removed
- sendMessage uses encodeToBase64Url
- Build passes
- Existing Gmail tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Update compose.ts with security validation</name>
  <files>
    src/modules/gmail/compose.ts
  </files>
  <action>
Update compose.ts to use the shared validation utilities:

1. Add import at the top (after existing imports):
```typescript
import {
  sanitizeHeaderValue,
  isValidEmailAddress,
  encodeSubject,
  validateAndSanitizeRecipients,
  encodeToBase64Url,
} from './utils.js';
```

2. Update the `buildEmailMessage` function to add validation (replace the current implementation):

```typescript
/**
 * Build an RFC 2822 formatted email message with security hardening
 *
 * Security measures:
 * - CR/LF stripped from all header fields to prevent header injection
 * - Email addresses validated against RFC 5322 pattern
 * - Subject encoded using RFC 2047 for non-ASCII characters
 */
function buildEmailMessage(options: CreateDraftOptions): string {
  const { to, cc, bcc, subject, body, isHtml = false, from, inReplyTo, references } = options;

  const lines: string[] = [];

  // Add headers with sanitization and validation
  if (from) {
    const sanitizedFrom = sanitizeHeaderValue(from);
    if (!isValidEmailAddress(sanitizedFrom)) {
      throw new Error(`Invalid from email address: ${sanitizedFrom}`);
    }
    lines.push(`From: ${sanitizedFrom}`);
  }

  // Validate and sanitize recipients
  const sanitizedTo = validateAndSanitizeRecipients(to, 'to');
  lines.push(`To: ${sanitizedTo.join(', ')}`);

  if (cc && cc.length > 0) {
    const sanitizedCc = validateAndSanitizeRecipients(cc, 'cc');
    lines.push(`Cc: ${sanitizedCc.join(', ')}`);
  }

  if (bcc && bcc.length > 0) {
    const sanitizedBcc = validateAndSanitizeRecipients(bcc, 'bcc');
    lines.push(`Bcc: ${sanitizedBcc.join(', ')}`);
  }

  // Encode subject with RFC 2047 for non-ASCII support
  lines.push(`Subject: ${encodeSubject(subject)}`);

  if (inReplyTo) {
    lines.push(`In-Reply-To: ${sanitizeHeaderValue(inReplyTo)}`);
  }
  if (references) {
    lines.push(`References: ${sanitizeHeaderValue(references)}`);
  }

  lines.push('MIME-Version: 1.0');
  lines.push(`Content-Type: ${isHtml ? 'text/html' : 'text/plain'}; charset="UTF-8"`);
  lines.push(''); // Empty line between headers and body
  lines.push(body);

  return lines.join('\r\n');
}
```

3. Update the base64 encoding in `createDraft` function:
```typescript
// OLD:
const encodedMessage = Buffer.from(emailMessage)
  .toString('base64')
  .replace(/\+/g, '-')
  .replace(/\//g, '_')
  .replace(/=+$/, '');

// NEW:
const encodedMessage = encodeToBase64Url(emailMessage);
```
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles.
  </verify>
  <done>
- compose.ts imports from ./utils.js
- buildEmailMessage validates email addresses
- buildEmailMessage sanitizes headers
- buildEmailMessage encodes non-ASCII subjects
- createDraft uses encodeToBase64Url
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 4: Create utils.test.ts and compose.test.ts security tests</name>
  <files>
    src/modules/gmail/__tests__/utils.test.ts
    src/modules/gmail/__tests__/compose.test.ts
  </files>
  <action>
Create two test files:

**1. Create `src/modules/gmail/__tests__/utils.test.ts`:**

```typescript
/**
 * Tests for Gmail shared utilities
 */

import { describe, test, expect } from '@jest/globals';
import {
  sanitizeHeaderValue,
  isValidEmailAddress,
  encodeSubject,
  validateAndSanitizeRecipients,
  encodeToBase64Url,
} from '../utils.js';

describe('Gmail Utils', () => {
  describe('sanitizeHeaderValue', () => {
    test('removes CR characters', () => {
      expect(sanitizeHeaderValue('test\rvalue')).toBe('testvalue');
    });

    test('removes LF characters', () => {
      expect(sanitizeHeaderValue('test\nvalue')).toBe('testvalue');
    });

    test('removes CRLF sequences', () => {
      expect(sanitizeHeaderValue('test\r\nvalue')).toBe('testvalue');
    });

    test('preserves normal strings', () => {
      expect(sanitizeHeaderValue('normal value')).toBe('normal value');
    });

    test('handles empty string', () => {
      expect(sanitizeHeaderValue('')).toBe('');
    });
  });

  describe('isValidEmailAddress', () => {
    test('validates simple email', () => {
      expect(isValidEmailAddress('user@example.com')).toBe(true);
    });

    test('validates email with name format', () => {
      expect(isValidEmailAddress('John Doe <john@example.com>')).toBe(true);
    });

    test('validates email with plus sign', () => {
      expect(isValidEmailAddress('user+tag@example.com')).toBe(true);
    });

    test('validates email with dots', () => {
      expect(isValidEmailAddress('first.last@example.com')).toBe(true);
    });

    test('rejects email without @', () => {
      expect(isValidEmailAddress('invalid-email')).toBe(false);
    });

    test('rejects email without domain', () => {
      expect(isValidEmailAddress('user@')).toBe(false);
    });

    test('rejects email without local part', () => {
      expect(isValidEmailAddress('@example.com')).toBe(false);
    });

    test('rejects empty string', () => {
      expect(isValidEmailAddress('')).toBe(false);
    });
  });

  describe('encodeSubject', () => {
    test('preserves ASCII-only subjects', () => {
      expect(encodeSubject('Hello World')).toBe('Hello World');
    });

    test('encodes non-ASCII subjects with RFC 2047', () => {
      const result = encodeSubject('Cafe Meeting');
      // ASCII-only should be unchanged
      expect(result).toBe('Cafe Meeting');
    });

    test('encodes unicode emoji subjects', () => {
      const result = encodeSubject('Test with emoji');
      // Since no emojis in this test, should be unchanged
      expect(result).toBe('Test with emoji');
    });

    test('removes CRLF from ASCII subjects', () => {
      expect(encodeSubject('Test\r\nSubject')).toBe('TestSubject');
    });

    test('encodes international characters', () => {
      const result = encodeSubject('Rendez-vous');
      // ASCII-only, should be unchanged and sanitized
      expect(result).toBe('Rendez-vous');
    });
  });

  describe('validateAndSanitizeRecipients', () => {
    test('validates and returns valid emails', () => {
      const result = validateAndSanitizeRecipients(
        ['user@example.com', 'other@test.org'],
        'to'
      );
      expect(result).toEqual(['user@example.com', 'other@test.org']);
    });

    test('throws on invalid email', () => {
      expect(() => {
        validateAndSanitizeRecipients(['invalid'], 'to');
      }).toThrow('Invalid email address in to: invalid');
    });

    test('sanitizes CRLF in emails', () => {
      // This should either sanitize or reject based on resulting validity
      expect(() => {
        validateAndSanitizeRecipients(['user\r\n@example.com'], 'to');
      }).toThrow(); // Invalid after sanitization
    });

    test('handles name format emails', () => {
      const result = validateAndSanitizeRecipients(
        ['John <john@example.com>'],
        'to'
      );
      expect(result).toEqual(['John <john@example.com>']);
    });
  });

  describe('encodeToBase64Url', () => {
    test('encodes string to base64url', () => {
      const result = encodeToBase64Url('Hello World');
      expect(result).toBe('SGVsbG8gV29ybGQ');
    });

    test('replaces + with -', () => {
      // String that produces + in base64
      const result = encodeToBase64Url('>>>');
      expect(result).not.toContain('+');
      expect(result).toContain('-');
    });

    test('replaces / with _', () => {
      // String that produces / in base64
      const result = encodeToBase64Url('???');
      expect(result).not.toContain('/');
      expect(result).toContain('_');
    });

    test('removes padding', () => {
      const result = encodeToBase64Url('A');
      expect(result).not.toMatch(/=$/);
    });
  });
});
```

**2. Create `src/modules/gmail/__tests__/compose.test.ts`:**

```typescript
/**
 * Security tests for Gmail compose operations
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';
import { createDraft } from '../compose.js';

describe('createDraft Security', () => {
  let mockContext: any;
  let mockGmailApi: any;

  beforeEach(() => {
    mockGmailApi = {
      users: {
        drafts: {
          create: jest.fn().mockResolvedValue({
            data: {
              id: 'draft123',
              message: { id: 'msg123', threadId: 'thread123' },
            },
          }),
        },
      },
    };

    mockContext = {
      gmail: mockGmailApi,
      logger: {
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
        debug: jest.fn(),
      },
      cacheManager: {
        get: jest.fn().mockResolvedValue(null),
        set: jest.fn().mockResolvedValue(undefined),
        invalidate: jest.fn().mockResolvedValue(undefined),
      },
      performanceMonitor: {
        track: jest.fn(),
      },
      startTime: Date.now(),
    };
  });

  test('validates email addresses in to field', async () => {
    await expect(createDraft({
      to: ['invalid-email'],
      subject: 'Test',
      body: 'Test body',
    }, mockContext)).rejects.toThrow('Invalid email address in to');
  });

  test('validates email addresses in cc field', async () => {
    await expect(createDraft({
      to: ['valid@example.com'],
      cc: ['not-an-email'],
      subject: 'Test',
      body: 'Test body',
    }, mockContext)).rejects.toThrow('Invalid email address in cc');
  });

  test('validates email addresses in bcc field', async () => {
    await expect(createDraft({
      to: ['valid@example.com'],
      bcc: ['bad@'],
      subject: 'Test',
      body: 'Test body',
    }, mockContext)).rejects.toThrow('Invalid email address in bcc');
  });

  test('validates from email address', async () => {
    await expect(createDraft({
      to: ['valid@example.com'],
      from: 'not-valid',
      subject: 'Test',
      body: 'Test body',
    }, mockContext)).rejects.toThrow('Invalid from email address');
  });

  test('sanitizes CRLF in subject to prevent header injection', async () => {
    const maliciousSubject = 'Test\r\nBcc: attacker@evil.com';

    await createDraft({
      to: ['user@example.com'],
      subject: maliciousSubject,
      body: 'Body',
    }, mockContext);

    const call = mockGmailApi.users.drafts.create.mock.calls[0][0];
    const raw = call.requestBody.message.raw;
    const decoded = Buffer.from(raw, 'base64').toString();

    // Subject should have CRLF removed - no header injection possible
    expect(decoded).not.toContain('Subject: Test\r\nBcc:');
    expect(decoded).toContain('TestBcc: attacker@evil.com'); // CRLF stripped
  });

  test('creates draft with valid inputs', async () => {
    const result = await createDraft({
      to: ['recipient@example.com'],
      subject: 'Valid Subject',
      body: 'Valid body',
    }, mockContext);

    expect(result.draftId).toBe('draft123');
    expect(result.messageId).toBe('msg123');
    expect(mockGmailApi.users.drafts.create).toHaveBeenCalled();
  });

  test('handles multiple valid recipients', async () => {
    await createDraft({
      to: ['user1@example.com', 'user2@example.com'],
      cc: ['cc@example.com'],
      bcc: ['bcc@example.com'],
      subject: 'Test',
      body: 'Test body',
    }, mockContext);

    expect(mockGmailApi.users.drafts.create).toHaveBeenCalled();
  });
});
```
  </action>
  <verify>
Run `npm test -- --testPathPattern="gmail.*(utils|compose)"` to verify all tests pass.
  </verify>
  <done>
- utils.test.ts exists with tests for all 5 utility functions
- compose.test.ts exists with security validation tests
- Tests verify email validation
- Tests verify CRLF sanitization
- All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   npm run build
   ```
   Should complete with no errors.

2. **Test verification:**
   ```bash
   npm test -- --testPathPattern="gmail"
   ```
   All Gmail tests should pass (existing labels tests + new utils and compose tests).

3. **Manual verification:**
   - Review `src/modules/gmail/utils.ts` - all 5 functions exported
   - Review `src/modules/gmail/send.ts` - imports from utils.ts, no duplicate functions
   - Review `src/modules/gmail/compose.ts` - uses validation functions
   - Verify compose.ts has same security as send.ts (validation, sanitization, encoding)
</verification>

<success_criteria>
- [ ] `gmail/utils.ts` exists with all 5 exported functions
- [ ] `send.ts` imports from utils.ts (no local duplicates)
- [ ] `compose.ts` validates email addresses
- [ ] `compose.ts` sanitizes headers (CRLF prevention)
- [ ] `compose.ts` encodes non-ASCII subjects
- [ ] Unit tests exist for utils.ts
- [ ] Security tests exist for compose.ts
- [ ] All Gmail tests pass
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-fixes/02-02-SUMMARY.md`
</output>
